# -*- coding: utf-8 -*-
"""Mancala con interfaz.ipynb

Automatically generated by Colaboratory.

# MANCALA

### Librerías auxiliares
"""

# pip install pygame

import copy as cp
import math
import pathlib
import platform
import pygame
import random

random.seed(random.SystemRandom().randint(0,123))
path = str(pathlib.Path(__file__).parent.absolute())
if platform.system() == "Darwin":
  path += "/"
else:
  path += "\\"

"""## Nodos
Estos nodos son la estructura de datos que forman el árbol generado por minmax.
En ellos se almacena la posición, el movimiento que llevo a esa jugada, los
posibles movimientos siguietnes, el puntaje heurístico de la posición y el
puntaje final al que lleva esa jugada.
"""

class Nodo:
  def __init__(self, b, mov):
    self.movimiento = mov
    self.posicion = b[0]
    self.estado = b[1]
    self.h = self.__score()
    self.movimientos = []
    self.f = True

  def __score(self):
    score = 0
    for i in range(6):
      score += self.posicion[i] * -30 * i
      score += self.posicion[i + 7] * 30 * i
    score += self.posicion[6] * -250
    score += self.posicion[13] * 250
    return score

  def nodo_posible(self, n):
    if (len(self.movimientos) > 0):
      if (n.h < self.movimientos[len(self.movimientos)-1].h):
        self.movimientos = self.movimientos + [n]
      else:
        for i in range(len(self.movimientos)):
          if (n.h >= self.movimientos[i].h):
            self.movimientos = self.movimientos[0:i] + [n] + self.movimientos[i:]
            break
    else:
      self.movimientos = [n]

"""## Mancala
Este es el juego de mesa y la inteligencia artificial que juega con nombre de cpu.
"""

class Mancala:
  def __init__(self, profundidad):
    self.board = [4,4,4,4,4,4,0,4,4,4,4,4,4,0]
    self.profundidad = profundidad
    self.inv = {7:5, 8:4, 9:3, 10:2, 11:1, 12:0,
              5:7, 4:8, 3:9, 2:10, 1:11, 0:12}

  ##############################################################################
  #################### FUNCIÓN PARA LLEVAR ACABO LOS TURNOS ####################
  ##############################################################################

  def turno(self, x, y, b):
    semillas = b[x - 1]
    b[x - 1] = 0
    offset = 0
    for i in range(semillas):
      if (x + i + offset >= len(b)):
        pos = x + i + offset - len(b) * math.floor((x + i + offset)/len(b))
      else:
        pos = x + i + offset

      if (i == semillas - 1):
        if (y):
          if (pos == 13):
            b[pos] += 1
            return [b,True]
          elif (b[pos] == 0 and pos >= 7 and pos < 13 and b[self.inv[pos]] > 0):
            b[13] += self.__robo(pos, b) + 1
          elif (pos == 6):
            if(b[x + semillas - len(b)] == 0):
              b[13] += self.__robo(x + semillas - len(b), b) + 1
            else:
              b[x + semillas - len(b)] += 1
          else:
            b[pos] += 1
        else:
          if (pos == 6):
            b[pos] += 1
            return [b,True]
          elif (b[pos] == 0 and pos >= 0 and pos < 6 and b[self.inv[pos]] > 0):
            b[6] += self.__robo(pos, b) + 1
          elif (pos == 13):
            if(b[x + semillas - len(b)] == 0):
              b[6] += self.__robo(x + semillas - len(b), b) + 1
            else:
              b[x + semillas - len(b)] += 1
          else:
            b[pos] += 1
      else:
        if (y and pos == 6) or (not y and pos == 13):
          offset += 1
          pos += 1
          if (pos >= len(b)):
            pos -= len(b)
        b[pos] += 1
    return [b,False]

  ##############################################################################
  ##################### FUNCIÓN PARA LLEVAR ACABO LOS ROBOS ####################
  ##############################################################################

  def __robo(self, n, b):
    if (n == 0 or n == 12):
      stealed_seeds = b[0] + b[12]
      b[0] = 0
      b[12] = 0
    elif (n == 1 or n == 11):
      stealed_seeds = b[1] + b[11]
      b[1] = 0
      b[11] = 0
    elif (n == 2 or n == 10):
      stealed_seeds = b[2] + b[10]
      b[2] = 0
      b[10] = 0
    elif (n == 3 or n == 9):
      stealed_seeds = b[3] + b[9]
      b[3] = 0
      b[9] = 0
    elif (n == 4 or n == 8):
      stealed_seeds = b[4] + b[8]
      b[4] = 0
      b[8] = 0
    elif (n == 5 or n == 7):
      stealed_seeds = b[5] + b[7]
      b[5] = 0
      b[7] = 0
    return stealed_seeds

  ##############################################################################
  ##################### FUNCIÓN PARA REVISAR SI YA TERMINÓ #####################
  ##############################################################################

  def game_over(self, b):
    vacio = True
    for i in range(6):
      if (b[i] > 0):
        vacio = False
        break
    if (vacio):
      return vacio
    vacio = True
    for i in range(6):
      if (b[i+7]) > 0:
        vacio = False
        break
    return vacio

  ##############################################################################
  ################### FUNCIÓN PARA HACER LOS AJUSTES FINALES ###################
  ##############################################################################

  def finalizar(self, board):
    b = cp.copy(board)
    for i in range(6):
      b[6] += b[i]
      b[i] = 0
      b[13] += b[i + 7]
      b[i + 7] = 0
    return b

  ##############################################################################
  ############## FUNCIÓN PARA PEDIR LA SIGUIENTE JUGADA DE LA IA ###############
  ##############################################################################

  def next(self, b):
    n = Nodo([b,True], -1)
    next = self.minimax(n, self.profundidad, -999999, 999999, n.estado)
    for mov in n.movimientos:
      if (mov.f >= next):
        return mov.movimiento

  ##############################################################################
  #################### MÉTODO MINMAX CON ALPHA-BETA PRUNING ####################
  ##############################################################################

  def minimax(self, actual, profundidad, alpha, beta, maximizar):
    if (profundidad == 0):
      return actual.h
    elif (self.game_over(actual.posicion)):
      provisional = Nodo([self.finalizar(actual.posicion), False],-1)
      return provisional.h

    for i in range(6):
      b = cp.copy(actual.posicion)
      if maximizar:
        j = i + 8
      else:
        j = i + 1
      if (b[j-1] > 0):
        pos_i = self.turno(j,maximizar,b)
        hijo = Nodo(pos_i,i+1)
        actual.nodo_posible(hijo)

    if (maximizar):
      maxEval = -999999
      for n in actual.movimientos:
        eval = self.minimax(n, profundidad-1, alpha, beta, n.estado)
        n.f = eval
        maxEval = max(maxEval, eval)
        alpha = max(alpha, eval)
        if beta <= alpha:
          break
      return maxEval

    else:
      minEval = 999999
      for n in reversed(actual.movimientos):
        eval = self.minimax(n, profundidad-1, alpha, beta, not n.estado)
        n.f = eval
        minEval = min(minEval, eval)
        beta = min(beta, eval)
        if beta <= alpha:
          break
      return minEval

"""## Interfaz
*Pygame no puede correr en colab*
"""
############################################################
########################## Assets ##########################
############################################################

icono = pygame.image.load(path + 'mancala.png')
tablero = pygame.image.load(path + 'tablero.png')
stones = pygame.image.load(path + 'stones.png')
numbers = pygame.image.load(path + 'numbers.png')
title = pygame.image.load(path + 'title.png')
buttonss = pygame.image.load(path + 'buttons.png')

############################################################
########################## Set up ##########################
############################################################

pygame.init()
screen = pygame.display.set_mode((1200,500))
pygame.display.set_caption("Mancala")
pygame.display.set_icon(icono)


############################################################
##################### Pequeños ajustes #####################
############################################################

num_score = {}
for i in range(10):
    num_score[i] = 12 * (i+1) + 18 * (i)

def Tablero():
  screen.blit(tablero, (87.5, 100))

def Titulo():
  screen.blit(title, (0, 0))
  screen.blit(buttonss, (402, 370), (792,0,396,100))

def Dificutad(x):
  screen.blit(buttonss, (418, 386), (x, 100,364,68))

def FinalScreen(x, alpha):
  surface = pygame.Surface((1200,500))
  surface.set_alpha(255-alpha)
  surface.blit(buttonss, (218.5, 100), (x, 268, 763,175))
  screen.blit(surface, (0, 0))

############################################################
######################### Semillas #########################
############################################################

def SetUpInicial():
    semillas = [[[0]]]*14
    for i in range(6):
      grupoA = [[[0]]]*4
      grupoB = [[[0]]]*4
      for j in range(4):
        if(j==0): offset = [0,0]
        elif(j==1): offset = [0,25]
        elif(j==2): offset = [25,0]
        else: offset = [25,25]
        grupoA[j] = [175 + 125*i + offset[0], 50 + offset[1], random.randint(0, 4)*25, random.randint(0,2)*25]
        grupoB[j] = [175 + 125*i + offset[0], 225 + offset[1], random.randint(0, 4)*25, random.randint(0,2)*25]
      semillas[i+7] = grupoA
      semillas[i] = grupoB
    semillas = semillas[0:7] + list(reversed(semillas[7:13])) + [semillas[13]]
    return semillas

def Semillas(semillas):
  for grupo in semillas:
    for semilla in grupo:
      if not(semilla[0] == 0):
        screen.blit(stones, (semilla[0] + 87.5, semilla[1] + 100), (semilla[2],semilla[3],25,25))

############################################################
########################### Score ##########################
############################################################

def Scoreboard(semillas):
  for i in range(len(semillas)):
    if (i < 6):
      drawScore(semillas, 175 + 125 * i + 87.5, 445, i)
    elif (i == 6):
      drawScore(semillas, 1200-48, 10, i)
    elif (i < 13):
      drawScore(semillas, 175 + 125 * (12-i) + 87.5, 60, i)
    else:
      drawScore(semillas, 10,10, i)

def drawScore(semillas,x,y,i):
  grupo = semillas[i]
  if len(grupo) == 1 and grupo[0][0] == 0:
    screen.blit(numbers, (x+20, y), (num_score[0], 12, 18, 30))
  else:
    if (len(grupo) > 9):
      decimal = math.floor(len(grupo)/10)
      unidad = len(grupo)%10
      screen.blit(numbers, (x, y), (num_score[decimal], 12, 18, 30))
      screen.blit(numbers, (x+20, y), (num_score[unidad], 12, 18, 30))
    else:
      screen.blit(numbers, (x+20, y), (num_score[len(grupo)], 12, 18, 30))

############################################################
################### Actualizar el tablero ##################
############################################################

def mover_tablero(semillas, x, turno):
    posinv = {7:5, 8:4, 9:3, 10:2, 11:1, 12:0, 5:7, 4:8, 3:9, 2:10, 1:11, 0:12}
    sem_ini = semillas[x-1]
    semillas[x-1] = [[0]]
    offset = 0
    for i in range(len(sem_ini)):
      if (x + i + offset >= len(semillas)):
        pos = x + i + offset - len(semillas) * math.floor((x + i + offset)/len(semillas))
      else:
        pos = x + i + offset

      if (turno and pos == 6):
          offset += 1
          pos += 1
      elif (not turno and pos == 13):
          offset += 1
          pos = 0

      robo = False
      if (semillas[pos][0] == [0]):
          if (i == len(sem_ini)-1 and pos != 6 and pos != 13 and not semillas[posinv[pos]][0] == [0]):
              if (not turno and pos < 6): robo = True
              elif (turno and pos > 6): robo = True
          semillas[pos] = []

      if (pos < 6):
          new_pos = sem_ini[i]
          new_pos[0] = 175 + 125*pos + 12.5 + random.randint(-30,30)
          new_pos[1] = 225 + 12.5 + random.randint(-30,30)
          semillas[pos].append(new_pos)
      elif (pos == 6):
          new_pos = sem_ini[i]
          new_pos[0] = 940 + random.randint(-10,20)
          new_pos[1] = 40 + random.randint(0,200)
          semillas[pos].append(new_pos)
      elif (pos < 13):
          new_pos = sem_ini[i]
          new_pos[0] = 175 + 125*(12-pos) + 12.5 + random.randint(-30,30)
          new_pos[1] = 50 + 12.5 + random.randint(-30,30)
          semillas[pos].append(new_pos)
      elif (pos == 13):
          new_pos = sem_ini[i]
          new_pos[0] = 45 + random.randint(-10,20)
          new_pos[1] = 40 + random.randint(0,200)
          semillas[pos].append(new_pos)
      if robo: semillas = mover_robo(semillas,pos, posinv[pos], turno)
    return semillas

def mover_robo(semillas, pos, posinv, turno):
  if(turno): x,fin = 45,13
  else: x,fin = 940,6
  for semilla in semillas[pos]:
    new_pos = semilla
    new_pos[0] = x + random.randint(-10,20)
    new_pos[1] = 40 + random.randint(0,200)
    semillas[fin].append(new_pos)
  semillas[pos] = [[0]]
  for semilla in semillas[posinv]:
    new_pos = semilla
    new_pos[0] = x + random.randint(-10,20)
    new_pos[1] = 40 + random.randint(0,200)
    semillas[fin].append(new_pos)
  semillas[posinv] = [[0]]
  return semillas


############################################################
########################### Menu ###########################
############################################################

scroll_dif = 0
set_dif = 3
pos_dif = 0
def MainMenu():
  global scroll_dif, set_dif, pos_dif
  click = False
  while True:
    screen.fill((64, 98, 102))
    mouse_x, mouse_y = pygame.mouse.get_pos()
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        pygame.quit()
        exit()
      if event.type == pygame.MOUSEBUTTONDOWN:
        if event.button == 1 and scroll_dif == 0:
          click = True

    MenuButtons(click, mouse_x, mouse_y, set_dif)
    scroll_dif = Arrows(click, mouse_x, mouse_y, scroll_dif)
    if scroll_dif > 0:
        if pos_dif < ((set_dif/3) - 1)*364:
            pos_dif += 2
        else:
          if(set_dif == 15):
            set_dif = 3
            pos_dif = 0
          scroll_dif = 0
        Dificutad(pos_dif)
    elif scroll_dif < 0:
        if(set_dif == 0):
          set_dif = 12
          pos_dif = 1456
        if pos_dif > ((set_dif/3) - 1)*364:
            pos_dif -= 2
        else:
          scroll_dif = 0
        Dificutad(pos_dif)
    else:
        Dificutad(pos_dif)
    Titulo()

    click = False
    pygame.display.update()

def MenuButtons(click, mouse_x, mouse_y, set_dif):
  button_start = pygame.Rect(402, 245, 396, 100)
  pygame.draw.rect(screen, (64, 98, 102), button_start, 0, 25)
  if button_start.collidepoint((mouse_x, mouse_y)):
    screen.blit(buttonss, (402, 245), (396,0,396,100))
    if click:
      semillas = SetUpInicial()
      GameStart(semillas, set_dif)
  else:
    screen.blit(buttonss, (402, 245), (0,0,396,100))

def Arrows(click, mouse_x, mouse_y, scroll_dif):
  global set_dif
  button_right = pygame.Rect(838, 394, 36,52)
  button_left = pygame.Rect(326, 394, 36,52)
  pygame.draw.rect(screen, (64, 98, 102), button_right)
  pygame.draw.rect(screen, (64, 98, 102), button_left)
  if button_right.collidepoint((mouse_x, mouse_y)):
    screen.blit(buttonss, (838, 394), (1224,0,36,52))
    screen.blit(buttonss, (326, 394), (1260,0,36,52))
    if click:
      set_dif += 3
      return 1
    return scroll_dif
  elif button_left.collidepoint((mouse_x,mouse_y)):
    screen.blit(buttonss, (838, 394), (1188,0,36,52))
    screen.blit(buttonss, (326, 394), (1296,0,396,100))
    if click:
      set_dif -= 3
      return -1
    return scroll_dif
  else:
    screen.blit(buttonss, (838, 394), (1188,0,36,52))
    screen.blit(buttonss, (326, 394), (1260,0,36,52))
    return scroll_dif


############################################################
########################### Game ###########################
############################################################
def GameStart(semillas, set_dif):
  juegoo = Mancala(set_dif)
  mancala_board = [juegoo.board, False]
  click = False
  while (not juegoo.game_over(mancala_board[0])):
    screen.fill((64, 98, 102))
    mouse_x, mouse_y = pygame.mouse.get_pos()
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        pygame.quit()
        exit()
      if event.type == pygame.MOUSEBUTTONDOWN:
        if event.button == 1:
          if not mancala_board[1]:
            click = True

    if mancala_board[1]:
      pygame.time.wait(1500)
      cpu_mov = juegoo.next(mancala_board[0]) + 7
      semillas = mover_tablero(semillas, cpu_mov, mancala_board[1])
      mancala_board = juegoo.turno(cpu_mov, mancala_board[1], mancala_board[0])

    Tablero()
    mancala_board = Movimientos(semillas, mouse_x, mouse_y, click, juegoo, mancala_board)
    Semillas(semillas)
    Scoreboard(semillas)

    if(juegoo.game_over(mancala_board[0])): break

    click = False
    pygame.display.update()
  semillas = Ajuste_Final(semillas)
  Pantalla_Final(semillas, 800)

############################################################
################# Movimientos del jugador ##################
############################################################

def Movimientos(semillas, mouse_x, mouse_y, click, juegoo, mancala_board):
  surface = pygame.Surface((1200,500))
  surface.set_alpha(1)
  movements = []

  for i in range(6):
    button_seed = pygame.draw.circle(surface, (0,0,0,0), (287.5 + 125 * i,350), 50, 50)
    movements.append(button_seed)

  if(click):
      mov = 0
      if movements[0].collidepoint((mouse_x, mouse_y)) and mancala_board[0][0] > 0: mov = 1
      if movements[1].collidepoint((mouse_x, mouse_y)) and mancala_board[0][1] > 0: mov = 2
      if movements[2].collidepoint((mouse_x, mouse_y)) and mancala_board[0][2] > 0: mov = 3
      if movements[3].collidepoint((mouse_x, mouse_y)) and mancala_board[0][3] > 0: mov = 4
      if movements[4].collidepoint((mouse_x, mouse_y)) and mancala_board[0][4] > 0: mov = 5
      if movements[5].collidepoint((mouse_x, mouse_y)) and mancala_board[0][5] > 0: mov = 6
      if (mov > 0):
          semillas = mover_tablero(semillas, mov, mancala_board[1])
          mancala_board = juegoo.turno(mov, mancala_board[1], mancala_board[0])
          mancala_board[1] = not mancala_board[1]
  return mancala_board

  screen.blit(surface, (0, 0))

############################################################
################# Ajustes y pantalla final #################
############################################################

def Ajuste_Final(semillas):
  for i in range(len(semillas)):
    if(i != 6 and i != 13 and semillas[i][0] != [0]):
      for semilla in semillas[i]:
        if(i < 6): x,fin = 940,6
        else: x,fin = 45,13
        new_pos = semilla
        new_pos[0] = x + random.randint(-10,20)
        new_pos[1] = 40 + random.randint(0,200)
        semillas[fin].append(new_pos)
      semillas[i] = [[0]]
  return semillas

def Pantalla_Final(semillas, countdown):
  click = False
  review = True
  if len(semillas[6]) > len(semillas[13]): x = 0
  else: x = 763

  while review:
    screen.fill((64, 98, 102))
    mouse_x, mouse_y = pygame.mouse.get_pos()
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        pygame.quit()
        exit()
      if event.type == pygame.MOUSEBUTTONDOWN:
        if event.button == 1:
          click = True
    Tablero()
    Semillas(semillas)
    Scoreboard(semillas)
    if(countdown > 255): countdown -= 1
    elif(countdown > 0):
      countdown -= 1
      FinalScreen(x, countdown)
    else:
      FinalScreen(x, 0)
      review = Return(click, mouse_x, mouse_y)

    click = False
    pygame.display.update()

def Return(click, mouse_x, mouse_y):
  button_return = pygame.Rect(454.5,360,291,100)
  pygame.draw.rect(screen, (0, 0, 0), button_return, 0,25)
  if button_return.collidepoint((mouse_x, mouse_y)):
    screen.blit(buttonss, (454.5,360), (292,168,292,100))
    if click:
      return False
    return True
  else:
    screen.blit(buttonss, (454.5,360), (0,168,292,100))
    return True

"""## Inicio del juego
Desde aquí se lleva a cabo el inicio del juego.
"""

MainMenu()
